<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  
  <title><![CDATA[深挖洞，广积粮，不称霸]]></title>
  <subtitle><![CDATA[Uncover hot project's vulnerabilities]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://huntcve.github.io//"/>
  <updated>2015-12-16T08:50:25.000Z</updated>
  <id>http://huntcve.github.io//</id>
  
  <author>
    <name><![CDATA[Seven Shen]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[一步一步调通stagefright exploit]]></title>
    <link href="http://huntcve.github.io/2015/12/16/debug-stagefright-exploit/"/>
    <id>http://huntcve.github.io/2015/12/16/debug-stagefright-exploit/</id>
    <published>2015-12-16T04:58:48.000Z</published>
    <updated>2015-12-16T08:50:25.000Z</updated>
    <content type="html"><![CDATA[<p>古语云：“蒙惠者虽知其然，而未必知其所以然也”。在漏洞利用的学习方面，我们不能只知其然，而必须知其所以然，才能真正掌握利用的精髓，以便学以致用。</p>
<h1 id="前言">前言</h1><p>安卓Media Server的漏洞近一年多以来一直是挖掘的重点。而其中libstagefirght无疑是最热点。自从今年八月份jduck公开披露以来，这个模块一直是谷歌撒钱的大户。近期我又从里面挖掘到一个critical的漏洞，有望在明年一月份bulletin里公布。种种迹象表明，这个模块漏洞还没有挖掘干净，应该还要继续臭名昭著一段时间。</p>
<p>目前关于libstagefright开源的exploit有两个版本，一个是jduck公布的<a href="https://blog.zimperium.com/the-latest-on-stagefright-cve-2015-1538-exploit-is-now-available-for-testing-purposes/" target="_blank" rel="external">exploit1</a>,另外一个是谷歌公布的<a href="https://code.google.com/p/google-security-research/issues/attachmentText?id=502&amp;aid=5020005000&amp;name=mp4_stagefright_release.py&amp;token=ABZ6GAdoREMO07ZRfflSFlJct3GtBbtypg%3A1450243091152" target="_blank" rel="external">exploit2</a>。这其中谷歌的版本做法比较精致，精确控制了内存布局，具体可以参见project zero的<a href="http://googleprojectzero.blogspot.tw/2015/09/stagefrightened.html" target="_blank" rel="external">博客</a>。Jduck的版本，网上没有过多的分析文章，乌云上有<a href="http://drops.wooyun.org/papers/10896" target="_blank" rel="external">一篇</a>只分析了一半，很关键的前期内存布局控制及触发点分析没有覆盖到，且作者似乎只是从静态角度分析了exploit chain的调用原理，这对于初学者想要彻底弄清楚整个利用的原理，还显不够。</p>
<p>本文从纯动态调试角度彻底阐述清楚该exploit的原理以及其所包含的问题。</p>
<h1 id="源码分析">源码分析</h1><p>在着手调试之前，我们先要分析一下Exploit源码。只有弄懂了代码，调试才能事半功倍。<br>Exploit利用的漏洞是CVE-2015-1538，具体对应的安卓部分代码如下：  </p>
<pre><code>status_t SampleTable::setSampleToChunkParams<span class="params">(off64_t data_offset, size_t data_size)</span> {
<span class="keyword">if</span> <span class="params">(mSampleToChunkOffset &gt;= <span class="number">0</span>)</span> {
    return ERROR_MALFORMED;
}
mSampleToChunkOffset = data_offset;
<span class="keyword">if</span> <span class="params">(data_size &lt; <span class="number">8</span>)</span> {
    return ERROR_MALFORMED;
}
uint8_t header[<span class="number">8</span>];
<span class="keyword">if</span> <span class="params">(mDataSource-&gt;readAt<span class="params">(
            data_offset, header, sizeof<span class="params">(header)</span>)</span> &lt; <span class="params">(ssize_t)</span>sizeof<span class="params">(header)</span>)</span> {
    return ERROR_IO;
}
<span class="keyword">if</span> <span class="params">(U32_AT<span class="params">(header)</span> != <span class="number">0</span>)</span> {
    <span class="comment">// Expected version = 0, flags = 0.</span>
    return ERROR_MALFORMED;
}
mNumSampleToChunkOffsets = U32_AT<span class="params">(&amp;header[<span class="number">4</span>])</span>;
<span class="keyword">if</span> <span class="params">(data_size &lt; <span class="number">8</span> + mNumSampleToChunkOffsets * <span class="number">12</span>)</span> {
    return ERROR_MALFORMED;
}
mSampleToChunkEntries =
    new SampleToChunkEntry[mNumSampleToChunkOffsets]; ----&gt; heap overflow
<span class="keyword">for</span> <span class="params">(uint32_t i = <span class="number">0</span>; i &lt; mNumSampleToChunkOffsets; ++i)</span> {
    uint8_t buffer[<span class="number">12</span>];
    <span class="keyword">if</span> <span class="params">(mDataSource-&gt;readAt<span class="params">(
                mSampleToChunkOffset + <span class="number">8</span> + i * <span class="number">12</span>, buffer, sizeof<span class="params">(buffer)</span>)</span>
            != <span class="params">(ssize_t)</span>sizeof<span class="params">(buffer)</span>)</span> {
        return ERROR_IO;
    }
    CHECK<span class="params">(U32_AT<span class="params">(buffer)</span> &gt;= <span class="number">1</span>)</span>;  <span class="comment">// chunk index is 1 based in the spec.</span>
    <span class="comment">// We want the chunk index to be 0-based.</span>
    mSampleToChunkEntries[i].startChunk = U32_AT<span class="params">(buffer)</span> - <span class="number">1</span>;
    mSampleToChunkEntries[i].samplesPerChunk = U32_AT<span class="params">(&amp;buffer[<span class="number">4</span>])</span>;
    mSampleToChunkEntries[i].chunkDesc = U32_AT<span class="params">(&amp;buffer[<span class="number">8</span>])</span>;
}
return OK;
}
</code></pre><p>其中在分配内存的时候会造成堆溢出，具体原理不再赘述。<br>在Exploit源码中，首先定义了两个地址：  </p>
<pre><code><span class="comment"># The address of a fake StrongPointer object (sprayed)</span>
<span class="variable">sp_addr =</span> <span class="number">0</span>x41d00010 <span class="comment"># takju @ imm76i – 2MB (via hangouts)</span>

<span class="comment"># The address to of our ROP pivot</span>
<span class="variable">newpc_val =</span> <span class="number">0</span>xb0002850 <span class="comment"># point sp at __dl_restore_core_regs</span>
</code></pre><p>其中sp_addr是heap spray后单个buffer的起始地址，newpc_val是god gadget restore_core_regs (libc.so中)的起始地址，具体用作stack pivot. 因为Exploit默认在ASLR disable的情况下工作，因此作者就hardcode了这两个地址。需要说明的是如果你在不同的device测试，这两个地址可能不一样。  </p>
<p>定义好了这两个地址后，就开始创建crack mp4文件。其中首先会把用来做Heap spray的buffer通过tx3g这个Box写进去：  </p>
<pre><code>page = page[:off] + rop + page[off+len<span class="params">(rop)</span>:] 
spray = page <span class="built_in">*</span> <span class="params">(<span class="params">(<span class="params">(<span class="number">2</span>*<span class="number">1024</span>*<span class="number">1024</span>)</span> / len<span class="params">(page)</span>)</span> – <span class="number">20</span>)</span> 
moov_data += make_chunk<span class="params">(‘tx3g’, spray)</span>
</code></pre><p>一共2M左右。单个buffer中包含这几部分数据：</p>
<ul>
<li>decStrong指令需要的相关寄存器数据（用来跳转到ROP）  </li>
<li>restore_core_regs需要的相关寄存器数据（ROP起始，栈翻转）</li>
<li>mprotect需要的相关寄存器数据（堆可执行）</li>
<li>Shellcode</li>
<li>一些其他gadget和补齐数据   </li>
</ul>
<p>需要注意的是，Exploit中tx3g生成的这个堆是放在第一个trak里面的，这会有问题。如果你在调试的过程中发现走到decStrong中必定发生crash,就是由于这个原因导致的，具体后面分析。  </p>
<p>Spray的内容准备好了之后，Exploit中生成了一堆各种各样的data box，这里的作用其实是试图生成堆空隙，以便后面分配的堆能够最终落到前面，为Overwrite提供可能。因为从代码看，造成溢出的堆其实是在最后的stsc 这个box解析时分配的，为了避免溢出后没东西可覆盖，需要在前面分配的各种堆中产生空隙，这样才有可能造成最后分配的堆反而跑到前面。安卓代码在解析这些box的时候都会生成临时堆，解析完后即free掉，另外，对同样的box，在第二次解析时会free掉第一次分配的内存（参考MetaData::setData），这两个原因导致这一堆data box解析结束后，在相关位置会留下堆空隙供后续溢出堆使用。 说到这里，解释一下为什么前面说谷歌的版本比较精致，就在于对这块堆布局的处理上，做的比较妥当，基本能保证溢出堆后面必有一个可以被用来利用的对象。而Jduck这个版本，并不能做这种保证，只是提供了可能。在调试的过程中证明了这点，溢出堆跑到前面的概率大概50%左右。  </p>
<p>最后，生成第二个trak，并塞入恶意的stsc box，触发堆溢出：</p>
<pre><code><span class="comment"># Build the nasty sample table to trigger the vulnerability here. </span>
stbl1 = make_stsc(<span class="number">3</span>, (<span class="number">0</span>x1200 / <span class="number">0</span>xc) – <span class="number">1</span>, sp_addr, <span class="keyword">True</span>) <span class="comment"># TRIGGER  </span>
</code></pre><p>这里最终会导致溢出堆之后的0x1200个字节被填入sp_addr。这里的0x1200已经超过了一个内存页，这个值可能是根据调试的device所设定的。无论如何一股脑溢出超过一个内存页却不希望导致crash这个做法其实挺坑爹的。我在调试的过程中发现，设这么大的值，很容易导致sample table对象被覆盖，于是溢出之后的循环还没跑完就crash了，根本跑不到析构函数里面去。  </p>
<p>到这里总结一下，作者是希望通过对象析构时调用decStrong来触发exploit chain。这就需要保证整个过程不能crash。另外，为了保证进入decStrong后 r0(this)指向sp_addr, 就需要能够覆盖对象指针，这个指针我反复调试之后，确定为只能是sample table指针，位于trac对象中。当然不同的机型也可能不一样，需要测试。  </p>
<h1 id="问题">问题</h1><p>在调试的过程中，过于信任Exploit源码，没有去质疑而被误导，走了不少弯路。这里把Jduck的源码中的问题罗列一下：</p>
<ul>
<li>ROP起始地址问题<br>调试的过程中发现指令走到mprotect函数时老是发生crash，分析了一下堆，发现spray 的堆的内容发生错位。ROP的起始位置不对。看了一下源码，ROP起始地址设的为0x34:</li>
</ul>
<pre><code><span class="constant">off</span> = 0x34 
<span class="constant">page</span> = page[:off] + rop + page[off+len(rop):] 
...
<span class="comment"># Add some identifiable stuff, just in case something goes awry… </span>
<span class="constant">rop_start_off</span> = 0x34 
<span class="constant">x</span> = rop_start_off + len(rop)
</code></pre><p>根据指令的调试，这个值应该是0x4c (同乌云的那篇文章)。 不知道jduc那边如何考虑，我们需要修改一下。</p>
<ul>
<li><p>tx3g box的位置问题<br>前面分析了exploit chain是通过析构触发的。MPEG4Extractor这个类的析构顺序如下：<br>~MPEG4Extractor-&gt;first Trak-&gt;first sp<sampletable\>-&gt;second Trak-&gt;second sp<sampletable\><br>通过调试发现溢出的堆有50%的概率分配在second Track之前，极少的概率分配在first Track或MPEG5Extractor之前，即我们只能覆盖second Track。但spray buffer是通过first Track的tx3g 生成的，在析构的时候，first Track先析构，这样会导致在析构sencond Track的时候spray buffer已经被free了。由于是2M的大堆，free之后进程已经无法访问。所以会发现decStrong中 的指令LDR   R4, [R0,#4]一经调用，必定会crash。 解决这个问题的办法就是把tx3g box放到第二个trak中，这样在sample table析构之前, spray buffer仍然是活的。下面两张图直观呈现了这个改动：<br><img src="/images/st/tx3g_original.png" alt="改动前" title="改动前"><br><img src="/images/st/tx3g_modified.png" alt="改动后" title="改动后"><br>至于原作者为何将tx3g至于第一个trak，目前我还没找到可以解释的合理理由。  </sampletable\></sampletable\></p>
</li>
<li><p>溢出字节的大小问题<br>在内存中几个关键的对象布局大概是这样，从低地址到高地址：<br>MPEG4Extractor对象-Trak1对象-Trak2对象-sample table2对象<br>而我们所关心的溢出堆大概有50%概率会落在Trak1对象与Trak2对象之间。这样就可以通过覆盖Trak2对象中的sample table2对象指针，达到在析构时控制r0的目的。要记住的是不能覆盖sample table2对象，因为在循环里面会用到，一旦覆盖，循环里面就crash了。因此设计一个合理的溢出值，就比较关键。在我的机子上经过若干次调试，我设的这个值为0xA50，大半个内存页的大小，可以使得成功率40-50%左右。  </p>
</li>
<li><p>几个地址问题<br>即使关闭ASLR，不同的版本几个地址也不一样。需要注意的是代码中用到的pop {pc}和pop {r0, r1, r2, r3, r4, pc}是16位的thumb指令，需要将ida中的地址+1。  另外heap spray的预测地址也要根据调试预先定义好。</p>
</li>
</ul>
<h1 id="调试">调试</h1><p>在解决了以上四个关键的问题后，就可以开始调试了。<br>我的机器是华为 T9510E, android 4.0.4.<br>需要先关闭aslr：</p>
<pre><code>echo <span class="number">0</span> &gt; /<span class="keyword">proc</span>/sys/kernel/randomize_va_space
</code></pre><p>ida attach media server，无需gdb server,直接用自带的android_server, nonpie版本。<br>通过下断点，可以看到第一个分配的Trak1的地址为：0x231d0<br><img src="/images/st/Trak1.png" alt="Trak1对象地址" title="Trak1对象地址">   </p>
<p>第一个分配的stsc1里面的SampleToChunkEntry对象地址为:0x23458<br><img src="/images/st/stsc1.png" alt="stsc1的SampleToChunkEntry对象地址" title="stsc1的SampleToChunkEntry对象地址">   </p>
<p>Trak2的地址为：0x23e70<br><img src="/images/st/trak2.png" alt="Trak2对象地址" title="Trak2对象地址">   </p>
<p>第二个分配的stsc2里面的SampleToChunkEntry对象地址为:0x236d0 (溢出堆),同时看到sample table对象地址为r4=0x24888<br><img src="/images/st/stsc2.png" alt="stsc2的SampleToChunkEntry对象地址" title="stsc2的SampleToChunkEntry对象地址">  </p>
<p>到这里我们可以计算一下，溢出堆到Trak2的距离为 0x23e70 - 0x236d0 = 0x7a0 &lt; 0xa50, 到sample table 对象的距离为 0x24888 - 0x236d0 = 0x11b8 &gt; 0xa50。 即我们的溢出会完全覆盖Track2对象同时不会覆盖到sample table对象，说明这次触发有可能成功。 继续调试：  </p>
<p>发现Trak2对象确实已经被完全覆盖，写入我们的预测地址:<br><img src="/images/st/trak2_overflow.png" alt="Trak2被覆盖" title="Trak2被覆盖">  </p>
<p>循环结束，没有crash，进入MPEG4Extractor的析构，此时发现我们预测的堆已经被spray到，并且刚好是起始位置:<br><img src="/images/st/heap_sprayed.png" alt="heap spray成功" title="heap spray成功">     </p>
<p>Trak1先析构:<br><img src="/images/st/trak1_decons.png" alt="Trak1先析构" title="Trak1先析构">  </p>
<p>Trak2开始析构:<br><img src="/images/st/trak2_decons.png" alt="Trak2开始析构" title="Trak2开始析构">   </p>
<p>sample table开始析构，a1 + 12为 sp<sampletable\>指针，已经被覆盖为sp_addr，所以调用decStrong后 r0即为sp_addr:<br><img src="/images/st/sampletabledecons.png" alt="sample table开始析构" title="sample table开始析构">   </sampletable\></p>
<p>进入decStrong, r0指向spray buffer头：<br><img src="/images/st/decstrong.png" alt="decStrong" title="decStrong">   </p>
<p>进入god gadget restore_core_regs, r0已经更新:<br><img src="/images/st/restorecorereg.png" alt="restore_core_regs" title="restore_core_regs">  </p>
<p>进入mprotect,r0已经被更新为页首，其他参数已经设入：<br><img src="/images/st/mprotect.png" alt="mprotect" title="mprotect">   </p>
<p>第一个pop, 16位的thumb指令:<br><img src="/images/st/pop1.png" alt="第一个pop" title="第一个pop">   </p>
<p>第二个pop, 16位的thumb指令:<br><img src="/images/st/pop2.png" alt="第二个pop" title="第二个pop"></p>
<p>shellcode, 即乌云文中所翻译的那段指令：<br><img src="/images/st/shellcode.png" alt="shellcode" title="shellcode"> </p>
<p>最终:<br><img src="/images/st/shell.png" alt="reverse shell" title="reverse shell">  </p>
<h1 id="总结">总结</h1><p>因为Media server crash后会不断重启，所以通过反复触发总能成功。我的机器概率大概是5-8次重启，能保证有一次成功。本文主要以动态调试方法详细阐述了该exploit的原理及相关问题，实践出真知，这些问题，或许因为某些原因在原作者的设备上并不存在（我对此表示怀疑），但通过这个调试过程，我们可以对漏洞利用的一般性方法有一个大概的了解。对文中指出的几个问题，有不同见解的朋友可以留言讨论。  </p>
<h1 id="修改的代码链接">修改的代码链接</h1><p><a href="https://github.com/huntcve/exploit/blob/master/cve-2015-1538-update.py" target="_blank" rel="external">CVE-2015-1538-update.py</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>古语云：“蒙惠者虽知其然，而未必知其所以然也”。在漏洞利用的学习方面，我们不能只知其然，而必须知其所以然，才能真正掌握利用的精髓，以便学以致用。</p>
<h1 id="前言">前言</h1><p>安卓Media Server的漏洞近一年多以来一直是挖掘的重点。而其中lib]]>
    </summary>
    
      <category term="Stagefright, expoit" scheme="http://huntcve.github.io/tags/Stagefright-expoit/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hunted CVEs in 2015]]></title>
    <link href="http://huntcve.github.io/2015/07/12/cveupdate/"/>
    <id>http://huntcve.github.io/2015/07/12/cveupdate/</id>
    <published>2015-07-12T03:08:39.000Z</published>
    <updated>2015-11-03T08:29:56.000Z</updated>
    <content type="html"><![CDATA[<p>Update:2015.10.28<br><a id="more"></a></p>
<table>
<thead>
<tr>
<th style="text-align:center">Project</th>
<th style="text-align:center">Module</th>
<th style="text-align:center">CVE</th>
<th style="text-align:center">Severity</th>
<th style="text-align:center">Type</th>
<th style="text-align:center">Date</th>
<th style="text-align:center">Description</th>
<th style="text-align:center">Links</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Apache</td>
<td style="text-align:center">Cordova</td>
<td style="text-align:center">CVE-2015-1835</td>
<td style="text-align:center">High</td>
<td style="text-align:center">RCE</td>
<td style="text-align:center">2015.4.30</td>
<td style="text-align:center">Remote modify Cordova configurations</td>
<td style="text-align:center"><a href="http://blog.trendmicro.com/trendlabs-security-intelligence/trend-micro-discovers-apache-vulnerability-that-allows-one-click-modification-of-android-apps/" target="_blank" rel="external">blog</a>, <a href="https://github.com/huntcve/CVE/tree/master/CVE-2015-1835" target="_blank" rel="external">poc</a></td>
</tr>
<tr>
<td style="text-align:center">Android</td>
<td style="text-align:center">MMS</td>
<td style="text-align:center">CVE-2015-3839</td>
<td style="text-align:center">Low</td>
<td style="text-align:center">DoS</td>
<td style="text-align:center">2015.6.4</td>
<td style="text-align:center">Messaging app DoS</td>
<td style="text-align:center"><a href="http://blog.trendmicro.com/trendlabs-security-intelligence/two-new-android-bugs-mess-up-messaging-may-lead-to-multiple-send-charges/" target="_blank" rel="external">blog</a>,poc</td>
</tr>
<tr>
<td style="text-align:center">Android</td>
<td style="text-align:center">MMS</td>
<td style="text-align:center">CVE-2015-3840</td>
<td style="text-align:center">Low</td>
<td style="text-align:center">Bypass</td>
<td style="text-align:center">2015.6.4</td>
<td style="text-align:center">MMS/SMS status modify</td>
<td style="text-align:center"><a href="http://blog.trendmicro.com/trendlabs-security-intelligence/two-new-android-bugs-mess-up-messaging-may-lead-to-multiple-send-charges/" target="_blank" rel="external">blog</a>,poc</td>
</tr>
<tr>
<td style="text-align:center">Android</td>
<td style="text-align:center">Bluethooth</td>
<td style="text-align:center">CVE-2015-3847</td>
<td style="text-align:center">Moderate</td>
<td style="text-align:center">Bypass,DoS</td>
<td style="text-align:center">2015.7.6</td>
<td style="text-align:center">Arbitrary SMS removal</td>
<td style="text-align:center">blog,poc</td>
</tr>
<tr>
<td style="text-align:center">Android</td>
<td style="text-align:center">Phone</td>
<td style="text-align:center">CVE-2015-3851</td>
<td style="text-align:center">Low</td>
<td style="text-align:center">Bypass,DoS</td>
<td style="text-align:center">2015.7.13</td>
<td style="text-align:center">Phone DoS/SIP profile removal</td>
<td style="text-align:center">blog,poc</td>
</tr>
<tr>
<td style="text-align:center">Android</td>
<td style="text-align:center">GPS</td>
<td style="text-align:center">CVE-2015-3852</td>
<td style="text-align:center">Low</td>
<td style="text-align:center">DoS</td>
<td style="text-align:center">2015.7.15</td>
<td style="text-align:center">Device continue reboot</td>
<td style="text-align:center">blog,poc</td>
</tr>
<tr>
<td style="text-align:center">Android</td>
<td style="text-align:center">StageFright</td>
<td style="text-align:center">CVE-2015-6600</td>
<td style="text-align:center">Critical</td>
<td style="text-align:center">RCE</td>
<td style="text-align:center">2015.7.31</td>
<td style="text-align:center">Heap buffer overflow</td>
<td style="text-align:center"><a href="http://blog.trendmicro.com/trendlabs-security-intelligence/android-security-update-includes-fix-for-stagefright-vulnerabilities-discovered-by-trend-micro/" target="_blank" rel="external">blog</a></td>
</tr>
<tr>
<td style="text-align:center">Android</td>
<td style="text-align:center">StageFright</td>
<td style="text-align:center">CVE-2015-6610</td>
<td style="text-align:center">High</td>
<td style="text-align:center">Privilege Elevation</td>
<td style="text-align:center">2015.8.19</td>
<td style="text-align:center">Heap buffer overflow</td>
<td style="text-align:center">blog</td>
</tr>
</tbody>
</table>
]]></content>
    <summary type="html">
    <![CDATA[<p>Update:2015.10.28<br>]]>
    
    </summary>
    
      <category term="CVE" scheme="http://huntcve.github.io/tags/CVE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[从zergRush深入理解Use After Free]]></title>
    <link href="http://huntcve.github.io/2015/06/14/uaf/"/>
    <id>http://huntcve.github.io/2015/06/14/uaf/</id>
    <published>2015-06-14T13:48:13.000Z</published>
    <updated>2015-06-14T14:14:30.000Z</updated>
    <content type="html"><![CDATA[<p>古语“道高一尺，魔高一丈”，用在如今的安全领域十分的恰如其分。</p>
<p>Use After Free(UAF)类型的漏洞近些年特别活跃，从WEB到桌面到移动端，屡屡被暴露于各种设备、平台、软件之中，究其原因，恐怕与系统软件厂商在针对传统型漏洞如缓冲区溢出等方面所作的持续性增强防范策略（Stack Canary, DEP/NX, ASLR…）不无干系。本文就Android平台一个知名UAF漏洞利用案列(zergRush)进行分析，深度探究UAF漏洞形成的原因及利用方法。</p>
<a id="more"></a>
<h1 id="Use_After_Free漏洞定义">Use After Free漏洞定义</h1><p>CWE 给出的定义如下：</p>
<blockquote>
<p>引用一段被释放的内存可导致程序崩溃，或处理非预期数值，或执行无干指令。</p>
</blockquote>
<p>扩展描述中有如下阐述：</p>
<blockquote>
<p>使用被释放的内存可带来诸多不利后果，根据具体实例和缺陷发生时机，轻则导致程序合法数据被破坏，重则可执行任意指令。最简单的导致数据被破坏的场景是系统对被释放内存进行了重利用。<br>UAF错误一般有两种原因导致：<br>•导致程序出错和发生异常的各种条件<br>•程序负责释放内存的指令发生混乱<br>问题内存在被释放后，在某个时间点又被合法地分配给了其他的指针，随后，这块内存释放之前的指针又被重新使用并且指向了新分配的同一内存的某个区域，但该段内存的数据已经发生变化，所有就造成了释放前指针对象的数据被破坏，这会导致程序行为未知。<br>如果碰巧这块问题内存新分配的数据是比如C++中的类，那这块内存堆上可能散落着各种函数指针，只要用shellcode的地址覆盖其中一个函数指针，就能够达成执行任意指令。 </p>
</blockquote>
<p>一个典型的UAF错误如下： </p>
<pre><code><span class="comment">//Example code, Language: C</span>
char<span class="built_in">*</span> ptr = <span class="params">(char*)</span>malloc <span class="params">(SIZE)</span>;
<span class="keyword">if</span> <span class="params">(err)</span> {
    abrt = <span class="number">1</span>;
    free<span class="params">(ptr)</span>;
}
...
<span class="keyword">if</span> <span class="params">(abrt)</span> {
    logError<span class="params">(<span class="string">"operation aborted before commit"</span>, ptr)</span>;
}
</code></pre><p>这里一旦错误发生，内存立刻被free，但内存指针ptr随后却被重新使用，从而引发错误。如果ptr在使用之前程序调用内存分配器申请内存并赋值给其他类型或对象指针，很有可能内存分配器分配的是同一块内存，结果就造成了两个不同类型的指针指向同一块内存，产生了混乱。根据程序实现的特定逻辑，这种混乱可能会使得恶意攻击成为可能，并且可以绕开传统的系统防御策略，如：stack cookie, DEP, ASLR。<br>这个例子是最简单的一种UAF错误场景，产生的原因是引用了悬挂指针（Dangling pointer）。如果在指针free后及时置NULL,那么对NULL指针的任何应用将导致程序终止，从而避免恶意利用的发生。<br>那是不是只要指针被释放后置NULL就可以避免产生UAF漏洞了？答案显然是NO。<br>CWE提供的对该漏洞的潜在缓解策略如下： </p>
<ul>
<li>选择具有自动内存管理功能的编程语言   </li>
<li>释放内存时务必置空指针。尽管如此，这种方法对针对多重或复杂数据结构利用的有效性有限 </li>
</ul>
<p>简言之，如果你不是用的像Java这样具有自动内存管理功能的高级语言，而是C/C++这样的需要自己管理内存的语言，即使没有犯明显的重用悬挂指针错误，一样也可能遭受UAF攻击。<br>这对C/C++编程者来说可能是个噩耗。事实上，UAF漏洞的攻击也确实基本都是针对C/C++这类原生程序的攻击，比如各类浏览器， ActiveX插件，操作系统等。下面我们结合一个在Android系统上知名的UAF漏洞利用（zergRush）案例深入分析一下这种攻击的原理和场景。 </p>
<h1 id="zergRush_(CVE-2011-3874)">zergRush (CVE-2011-3874)</h1><p>CVE-2011-3874是Android系统早期一个著名的漏洞，被Revolutionary 小组用来集成在zergRush工具中对Android2.2-2.3版本进行ROOT提权。网上对该漏洞的原理分析并不多，<a href="http://www.2cto.com/Article/201410/339738.html" target="_blank" rel="external">zergRush (CVE-2011-3874)提权漏洞分析</a>算是讲的比较具体的，但有几个关键点没有讲清楚，导致初学者可能不太容易理解，并且这几个关键点是整个漏洞利用的精髓，涉及到UAF产生和利用的原理，因此有必要在这里重新交代一下，以便更好地理解UAF，当然，直接看懂了的可略过。 </p>
<p>不赘述，直接进入要点： </p>
<h2 id="关键点一：free任意地址">关键点一：free任意地址</h2><p>use-after-free, 第一步，自然是free。只有能够free掉任意地址，才能利用任意地址，进而做更“龌蹉”的事情。 如果只能free固定地址，对现代的操作系统来说威胁并不大，漏洞进一步利用的空间也不大。要实现free任意地址，就需要指针的值即指针本身所在的栈空间（不是指针指向的堆空间）是可控的。但是程序中指针的值都是strdup返回的，这是内存分配器控制的，我们如何干预呢？<br>argv[argc++] = strdup(tmp);</p>
<p>这就涉及到第二个关键点，缓冲区溢出的用途。 </p>
<h2 id="关键点二：缓冲区溢出与UAF的关系">关键点二：缓冲区溢出与UAF的关系</h2><p>代码其实有两个缓冲区溢出漏洞，一个是字符指针数组argv，一个是字符数组tmp。这里只利用了argv，因为我们要free指针。argv是有16个元素的字符指针数组，按道理只要给它输入17个元素即可溢出且最后一个元素会覆盖到tmp数组的前四个字节，那为何原文要构造18个参数传入呢？<br>“cmd p1 p2 p3 p4 p5 p6 p7 p8 p9 p10 p11 p12 p13 p14 p15 p16 \x78\x56\x34\x12”</p>
<p>既然p16就已经溢出到了tmp内存，为何不把任意地址放在这里而要放在后一位？其实作者在这里没有交代清楚，我们先看一下这个函数的源码（略去了无关部分）： </p>
<pre><code><span class="keyword">void</span> FrameworkListener::dispatchCommand(SocketClient *cli, <span class="keyword">char</span> *data) {      
    FrameworkCommandCollection::iterator i;                                   
    <span class="keyword">int</span> argc = <span class="number">0</span>;                                                             
    <span class="keyword">char</span> *argv[FrameworkListener::CMD_ARGS_MAX];                              
    <span class="keyword">char</span> tmp[<span class="number">255</span>];                                                            
    <span class="keyword">char</span> *p = data;                                                           
    <span class="keyword">char</span> *q = tmp;                                                            
    <span class="keyword">bool</span> esc = <span class="keyword">false</span>;                                                         
    <span class="keyword">bool</span> quote = <span class="keyword">false</span>;                                                       
    <span class="keyword">int</span> k;                                                                    

    <span class="built_in">memset</span>(argv, <span class="number">0</span>, <span class="keyword">sizeof</span>(argv));                                            
    <span class="built_in">memset</span>(tmp, <span class="number">0</span>, <span class="keyword">sizeof</span>(tmp));                                              
    <span class="keyword">while</span>(*p) {                                                               
        ...  

        *q = *p++; 
        <span class="comment">//参数截取分支                                                          </span>
        <span class="keyword">if</span> (!quote &amp;&amp; *q == <span class="string">' '</span>) {                                           
            *q = <span class="string">'\0'</span>;                                                       
            argv[argc++] = strdup(tmp);                                      
            <span class="built_in">memset</span>(tmp, <span class="number">0</span>, <span class="keyword">sizeof</span>(tmp));                                     
            q = tmp;                                                         
            <span class="keyword">continue</span>;                                                        
        }                                                                    
        q++;                                                                 
    }                                                                        

    argv[argc++] = strdup(tmp);                                              
    ....                                                                           
    <span class="keyword">int</span> j;                                                                   
    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; argc; j++)                                               
        <span class="built_in">free</span>(argv[j]);                                                       
    <span class="keyword">return</span>;
} 
</code></pre><p>程序是用空格来分割解析参数的，当解析到第16个空格（即p15 p16之间）的时候，tmp里存的是p15，内存分配器在堆上分配一块新的内存写入p15并把地址赋给argv[15]，随后将tmp数组清空，若参数到p16截止，则while循环不会再进入参数截取分支，读完p16后while结束，此时tmp存的是p16，最后一条strdup会将p16所在的堆的地址写到argv[16],即tmp数组首地址（头4个字节）。这样整个解析流程结束，cmd到p15的堆指针写到了argv[0-15]中，p16的堆地址写到了tmp的前四个字节中，这样任然没办法控制free任意地址，因为argv的17个指针都是strdup返回的,内存布局如下：<br><img src="/images/uaf/uaf_input_17.jpg" alt="输入17个参数" title="输入17个参数]"> </p>
<p>但如果是18个参数，即p16后还有一个参数（这里是\x78\x56\x34\x12），那while循环会继续解析p16和\x78\x56\x34\x12之间的空格，此时tmp存的是p16，内存分配器在堆上分配一块新的内存写入p16并把地址赋给argv[16]，即tmp的前四个字节，同时清空tmp，意味着刚才的地址被置0. 然后程序继续读入\x78\x56\x34\x12到tmp，并且不会进入参数截取分支，跳出while，此时tmp前四字节存的是0x78,0x56,0x34,0x12，即argv[16]指针的值。最后一条strdup将开辟一个新的堆空间并写入\x78\x56\x34\x12，同时将地址赋值给arg[17]，即tmp[4] - tmp[7],不影响tmp[0]-tmp[3]. 至此，argv[0-15]和argv[17]存的都是strdup返回的地址，只有argv[16]存的是我们输入的地址，即0x12345678，达成free任意地址的目的，内存布局如下：<br><img src="/images/uaf/uaf_input_18.jpg" alt="输入18个参数" title="输入18个参数"> </p>
<p>简单的理解，当输入17个参数时，最后一个参数虽然会被写入tmp前四字节，但随即被堆指针覆盖；当输入参数大于17时，最后一个参数被写入tmp前四字节，不会被覆盖，之后的内存才被覆盖。以下是输入19个参数时的内存布局：<br><img src="/images/uaf/uaf_input_19.jpg" alt="输入19个参数" title="输入19个参数">  </p>
<p>因此，利用缓冲区溢出的根本目的是将溢出的指针所在的内存写入我们的输入，即间接给溢出指针赋值，这个过程是与程序实现逻辑息息相关的，18个参数不多不少，刚好满足需求，因地制宜地构造输入，这也是攻击的精髓。 </p>
<h2 id="关键点三：为何要寻找带vtable的对象？">关键点三：为何要寻找带vtable的对象？</h2><p>实际上当我们能够控制free任意指针时，基本能够实现劫持任何对象，这里使用带vtable的FrameworkCommand对象，一方面是因为在函数内部直接调用了该对象的虚函数runCommand,攻击方便，只需对同一函数构造输入二次调用即可，另一方面，带虚函数的对象，vtable的指针都放在对象内存的最前面，也就是我们构造的任意地址，这就使得对象的虚表直接被我们劫持，进而可用任意shellcode地址去覆盖对象的任何函数指针，达到了执行任意代码的目的。</p>
<h2 id="关键点四：为何二次调用dispatchCommand时strdup(tmp)第一次调用返回的即是FrameworkCommand指针？">关键点四：为何二次调用dispatchCommand时strdup(tmp)第一次调用返回的即是FrameworkCommand指针？</h2><p>这取决于内存分配器。Android使用的dlmalloc是一个高效的内存分配器。在某些情况下内存被free后不会马上释放回内核，而是保留给应用程序重新申请。这使得被我们free掉的任意内存，在紧接着下一次分配的过程中，有很大肯能被重新分配使用。第一次strdup正是导致了这样的结果，不同类型的指针指向了同一块内存，当我们用新指针向这块内存写入任意数据的同时，也在覆盖原指针所指向的数据结构。而当原指针复用时，攻击便发生了。这就是use-after-free中的use。 </p>
<p>至此四个关键点分析完成，use-after-free的过程也结束了，我们已经能够开始执行任意代码了。 </p>
<h1 id="总结">总结</h1><p>通过这个案例我们看到，编程人员并没有犯明显的重用悬挂指针错误，但最终还是导致了use-after-free，原因就是因为缓冲区溢出了，并且是指针所在的缓冲区溢出，这就导致溢出的指针超出了程序本身能够掌控的范围，被攻击者利用。同时我们也注意到，该攻击对缓冲区溢出的利用十分聪明，并没有毁坏stack cookie或者是EIP，仅仅溢出了相邻的局部变量的前八个字节，栈帧本身还是完好的，这也是该攻击能够很大程度绕开系统保护措施的主要原因。<br>可以预见，在一定长的时间内，use-after-free还是会成为一种主要的漏洞利用手段。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>古语“道高一尺，魔高一丈”，用在如今的安全领域十分的恰如其分。</p>
<p>Use After Free(UAF)类型的漏洞近些年特别活跃，从WEB到桌面到移动端，屡屡被暴露于各种设备、平台、软件之中，究其原因，恐怕与系统软件厂商在针对传统型漏洞如缓冲区溢出等方面所作的持续性增强防范策略（Stack Canary, DEP/NX, ASLR…）不无干系。本文就Android平台一个知名UAF漏洞利用案列(zergRush)进行分析，深度探究UAF漏洞形成的原因及利用方法。</p>]]>
    
    </summary>
    
      <category term="vulnerability, 漏洞" scheme="http://huntcve.github.io/tags/vulnerability-%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
</feed>